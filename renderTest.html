<!DOCTYPE html>
  <head>

  </head>
  <body>
    <canvas id='myCanvas' width='1000px' height='1000px'></canvas>
    <script>
      var canvas = document.getElementById('myCanvas');
      var ctx = canvas.getContext('2d');

      var black = '#000000';
var pseudoSprite = {symmetryLine: 0, xCenter: 677.5, yCenter: 250, width: 509, height: 343, shapes: [
{symmetryBool: false, color: black, globalAlpha: 0.55, type: 'curvedshape',positions: [

{x: -0.9400785854616895, y: 0.21574344023323616},
{x: -0.9400785854616895, y: 0.062196307094266386},
{x: -0.9400785854616895, y: -0.09135082604470354},
{x: -0.9400785854616895, y: -0.24489795918367346},
{x: -0.9145383104125737, y: -0.46647230320699706},
{x: -0.7043222003929273, y: -0.5539358600583091},
{x: -0.4823182711198428, y: -0.4839650145772595},
{x: -0.0343811394891945, y: -0.27696793002915454},
{x: -0.3487229862475442, y: 0.13022351797861992},
{x: -0.2819253438113949, y: 0.43731778425655976},
{x: -0.4004584151931892, y: 0.43731778425655976},
{x: -0.5189914865749835, y: 0.43731778425655976},
{x: -0.637524557956778, y: 0.43731778425655976},
{x: -0.6060903732809431, y: 0.2283770651117591},
{x: -0.24656188605108054, y: -0.13411078717201166},
{x: -0.5176817288801572, y: -0.2303206997084548},
{x: -0.611984282907662, y: -0.26239067055393583},
{x: -0.6886051080550099, y: -0.2857142857142857},
{x: -0.8261296660117878, y: -0.10787172011661808},
{x: -0.9007858546168959, y: 0.03206997084548105},
{x: -0.7960052390307794, y: 0.2536443148688047},
{x: -0.6944990176817288, y: 0.40233236151603496},
{x: -0.8339882121807466, y: 0.36151603498542273},
{x: -0.8870333988212181, y: 0.2886297376093295},
]},
{symmetryBool: true, color: black, globalAlpha: 0.48, type: 'curvedshape',positions: [

{x: -0.05795677799607073, y: 0.3819241982507289},
{x: -0.2125081859855926, y: 0.21282798833819241},
{x: -0.11886051080550099, y: 0.026239067055393587},
{x: -0.5216110019646365, y: -0.12536443148688048},
{x: -0.14636542239685657, y: -0.05539358600583091},
{x: -0.2518009168303863, y: -0.41690962099125367},
{x: -0.1168958742632613, y: -0.5626822157434402},
{x: -0.09724950884086467, y: -0.2478134110787172},
{x: 0.05992141453831041, y: -0.043731778425655975},
]},
]}
      var renderPseudoSprite = function(object, context){
        object.shapes.forEach(function(shape){
          switch (shape.type){
            case 'polyline':
              renderPolyline(object, context, shape);
              break;
            case 'curvedline':
              renderCurvedLine(object, context, shape);
              debugRender(object, context, shape);
              break;
            case 'polygon':
              renderPolygon(object, context, shape);
              break;
            case 'circle':
              renderCircle(object, context, shape);
              break;
            case 'curvedshape':
              renderCurvedShape(object, context, shape);
              //renderPolygon(object, context, shape);
              debugRender(object,context,shape);
              break;

          }
        });
      }
      var renderPolygon = function(object, context, shape){
        context.beginPath();
        context.moveTo(object.xCenter + (shape.positions[0].x * object.width), object.yCenter + (shape.positions[0].y * object.height));
        shape.positions.forEach(function(p){
          context.lineTo(object.xCenter + (p.x * object.width), object.yCenter + (p.y * object.height) );
        });
        context.fillStyle = shape.color;
        context.globalAlpha = shape.globalAlpha;
        context.fill();
        context.closePath();
        if (shape.symmetryBool === true){
          symmetryRenderPoly(object, context, shape);
        }
      }
      var renderCircle = function(object, context, shape){
        context.beginPath();
        context.arc(object.xCenter + (shape.positions[0].x * object.width), object.yCenter + (object.height * shape.positions[0].y), (shape.radius * object.width), 0, Math.PI * 2);
        context.fillStyle = shape.color;
        context.globalAlpha = shape.globalAlpha;
        context.fill()
        context.closePath();
        if (shape.symmetryBool === true){
          var flippedX = Math.abs(shape.positions[0].x - object.symmetryLine);
          if (shape.positions[0].x > object.symmetryLine){
            flippedX = flippedX * -1;
          }
          context.beginPath();
          context.arc(object.xCenter + (flippedX * object.width), object.yCenter + (shape.positions[0].y * object.height), (shape.radius * object.width), 0, Math.PI * 2)
          context.fill();
          context.closePath();
        }
      }
      var renderPolyline = function(object, context, shape){
        context.beginPath();
        context.moveTo(object.xCenter + (shape.positions[0].x * object.width), object.yCenter + (shape.positions[0].y * object.height));
        shape.positions.forEach(function(p){
          context.lineTo(object.xCenter + (p.x * object.width), object.yCenter + (p.y * object.height));
        });
        context.lineWidth = shape.lineWidth;
        context.globalAlpha = shape.globalAlpha;
        context.strokeStyle = shape.color;
        context.stroke();
        context.closePath();
        if (shape.symmetryBool == true){
          symmetryRenderPoly(object, context, shape);
        }
      }
      var renderCurvedShape = function(object, context, shape){
        context.beginPath();
        context.moveTo(object.xCenter + (shape.positions[0].x * object.width) , object.yCenter + (shape.positions[0].y * object.height) );
        for (var i = 1; i < shape.positions.length; i+=3){
          var lastpoint = {x: undefined, y: undefined};
          if (i+3 > shape.positions.length){
            lastpoint.x = shape.positions[0].x;
            lastpoint.y = shape.positions[0].y;
          } else{
            lastpoint.x = shape.positions[i+2].x;
            lastpoint.y = shape.positions[i+2].y;
          }
          context.bezierCurveTo(object.xCenter + (shape.positions[i].x * object.width), object.yCenter + (shape.positions[i].y * object.height), object.xCenter + (shape.positions[i+1].x * object.width), object.yCenter + (shape.positions[i+1].y * object.height), object.xCenter + (lastpoint.x * object.width), object.yCenter + (lastpoint.y * object.height) );
        }

        context.fillStyle = shape.color;
        context.globalAlpha = shape.globalAlpha;
        context.fill();
        context.closePath();
        if (shape.symmetryBool === true){
          symmetryRenderCurvedShape(object, context, shape);
        }
      }

      var renderCurvedLine = function(object, context, shape){
        context.beginPath();
        context.moveTo(object.xCenter + (shape.positions[0].x * object.width), object.yCenter + (shape.positions[0].y * object.height));
        for (var i = 1; i < shape.positions.length - 1; i +=3 ){
          var lastpoint = {x: undefined, y: undefined};
          if (shape.positions[i+2] === undefined){
            continue;
          }
          context.bezierCurveTo(object.xCenter + (shape.positions[i].x * object.width), object.yCenter + (shape.positions[i].y * object.height), object.xCenter + (shape.positions[i+1].x * object.width), object.yCenter + (shape.positions[i+1].y * object.yCenter), object.xCenter + (shape.positions[i+2].x * object.width), object.yCenter + (shape.positions[i+2].y * object.height) );
        }
        context.strokeStyle = shape.color;
        context.lineWidth = shape.lineWidth;
        context.globalAlpha = shape.globalAlpha;
        context.stroke();
        context.closePath();
      }
      var symmetryRenderPoly = function(object, context, shape){
        context.beginPath();
        var initFlippedX = Math.abs(shape.positions[0].x - object.symmetryLine);
        if (shape.positions[0].x > object.symmetryLine){
          initFlippedX = initFlippedX * -1;
        }
        context.moveTo(object.xCenter + (initFlippedX * object.width), object.yCenter + (shape.positions[0].y * object.height))
        shape.positions.forEach(function(p){
          var flippedX = Math.abs(p.x - object.symmetryLine);
          if (p.x > object.symmetryLine){
            flippedX = flippedX * -1;
          }
          context.lineTo(object.xCenter + (flippedX * object.width), object.yCenter + (p.y * object.height) );
        });
        switch (shape.type){
          case 'polyline':
            context.stroke();
            break;
          case 'polygon':
            context.fill();
            break;
        }
        context.closePath();
      }
      var symmetryRenderCurvedShape = function(object, context, shape){
        context.beginPath();
        var initFlippedX = Math.abs(shape.positions[0].x - object.symmetryLine);
        if (shape.positions[0].x > object.symmetryLine){
          initFlippedX = initFlippedX * -1;
        }
        context.moveTo(object.xCenter + (initFlippedX * object.width) , object.yCenter + (shape.positions[0].y * object.height) );
        for (var i = 1; i < shape.positions.length; i+=3){
          var lastpoint = {x: undefined, y: undefined};
          if (i+3 > shape.positions.length){
            lastpoint.x = Math.abs(shape.positions[0].x - object.symmetryLine);
            if (shape.positions[0].x > object.symmetryLine){
              lastpoint.x = lastpoint.x * -1;
            }
            lastpoint.y = shape.positions[0].y;
          } else{
            lastpoint.x = Math.abs(shape.positions[i+2].x - object.symmetryLine);
            if (shape.positions[i+2].x > object.symmetryLine){
              lastpoint.x = lastpoint.x * -1;
            }
            lastpoint.y = shape.positions[i+2].y;
          }
          var oneX = Math.abs(shape.positions[i].x - object.symmetryLine);
          if (shape.positions[i].x > object.symmetryLine){
            oneX = oneX * -1;
          }
          var twoX = Math.abs(shape.positions[i+1].x - object.symmetryLine);
          if (shape.positions[i+1].x > object.symmetryLine){
            twoX = twoX * -1;
          }
          context.bezierCurveTo(object.xCenter + (oneX * object.width), object.yCenter + (shape.positions[i].y * object.height), object.xCenter + (twoX * object.width), object.yCenter + (shape.positions[i+1].y * object.height), object.xCenter + (lastpoint.x * object.width), object.yCenter + (lastpoint.y * object.height) );
        }
        context.fill();
        context.closePath();
      }
      var debugRender = function(object, context, shape){
        shape.positions.forEach(function(p){
          context.beginPath();
          context.arc(object.xCenter + (p.x * object.width), object.yCenter + (p.y * object.height), 10, 0, Math.PI * 2);
          context.globalAlpha = 0.5;
          context.fillStyle = 'black';
          context.fill();
          context.closePath();
        });
      }
      var debugPoint = function(x, y){
        ctx.beginPath();
        ctx.arc(x,y,10,0,Math.PI * 2);
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = 'red';
        ctx.fill();
        ctx.closePath();
        console.log(x + ", " + y);
      }
      var incX = 5;
      var incY = 10;
      var update = function(){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        renderPseudoSprite(pseudoSprite, ctx);
      }
      update();
      //setInterval(update, 25);
    </script>
  </body>
</html>
